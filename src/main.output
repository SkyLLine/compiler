Nonterminals useless in grammar

    type


Terminals unused in grammar

    IF
    ELSE
    WHILE
    FOR
    RETURN
    PRINTF
    SCANF
    T_INT
    T_BOOL
    T_CHAR
    T_STRING
    T_VOID
    T_STRUCT
    T_INT_POINTER
    T_CHAR_POINTER
    LOP_ASSIGN
    ADD_ASSIGN
    SUB_ASSIGN
    MUL_ASSIGN
    DIV_ASSIGN
    MOD_ASSIGN
    CHAR
    BOOL
    STRING
    SEMICOLON
    POINT
    LPAREN
    RPAREN
    LBRACE
    RBRACE
    GT
    LT
    GE
    LE
    EQ
    NE
    ADD
    SUB
    MUL
    DIV
    MOD
    LOG_AND
    LOG_OR
    NOT
    NEG
    POS
    SELF_INC
    SELF_DEC
    GET_ADDRESS


Rules useless in grammar

    6 type: T_INT
    7     | T_CHAR
    8     | T_VOID
    9     | T_STRING
   10     | T_STRUCT IDENTIFIER


State 1 conflicts: 1 shift/reduce


Grammar

    0 $accept: idlist $end

    1 idlist: variable
    2       | variable COMMA idlist

    3 variable: IDENTIFIER
    4         | IDENTIFIER LBRACK INTEGER RBRACK
    5         | variable LBRACK INTEGER RBRACK


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    IF (258)
    ELSE (259)
    WHILE (260)
    FOR (261)
    RETURN (262)
    PRINTF (263)
    SCANF (264)
    T_INT (265)
    T_BOOL (266)
    T_CHAR (267)
    T_STRING (268)
    T_VOID (269)
    T_STRUCT (270)
    T_INT_POINTER (271)
    T_CHAR_POINTER (272)
    LOP_ASSIGN (273)
    ADD_ASSIGN (274)
    SUB_ASSIGN (275)
    MUL_ASSIGN (276)
    DIV_ASSIGN (277)
    MOD_ASSIGN (278)
    IDENTIFIER (279) 3 4
    INTEGER (280) 4 5
    CHAR (281)
    BOOL (282)
    STRING (283)
    SEMICOLON (284)
    COMMA (285) 2
    POINT (286)
    LPAREN (287)
    RPAREN (288)
    LBRACK (289) 4 5
    RBRACK (290) 4 5
    LBRACE (291)
    RBRACE (292)
    GT (293)
    LT (294)
    GE (295)
    LE (296)
    EQ (297)
    NE (298)
    ADD (299)
    SUB (300)
    MUL (301)
    DIV (302)
    MOD (303)
    LOG_AND (304)
    LOG_OR (305)
    NOT (306)
    NEG (307)
    POS (308)
    SELF_INC (309)
    SELF_DEC (310)
    GET_ADDRESS (311)


Nonterminals, with rules where they appear

    $accept (57)
        on left: 0
    idlist (58)
        on left: 1 2
        on right: 0 2
    variable (59)
        on left: 3 4 5
        on right: 1 2 5


State 0

    0 $accept: . idlist $end

    IDENTIFIER  shift, and go to state 1

    idlist    go to state 2
    variable  go to state 3


State 1

    3 variable: IDENTIFIER .
    4         | IDENTIFIER . LBRACK INTEGER RBRACK

    LBRACK  shift, and go to state 4

    LBRACK    [reduce using rule 3 (variable)]
    $default  reduce using rule 3 (variable)


State 2

    0 $accept: idlist . $end

    $end  shift, and go to state 5


State 3

    1 idlist: variable .
    2       | variable . COMMA idlist
    5 variable: variable . LBRACK INTEGER RBRACK

    COMMA   shift, and go to state 6
    LBRACK  shift, and go to state 7

    $default  reduce using rule 1 (idlist)


State 4

    4 variable: IDENTIFIER LBRACK . INTEGER RBRACK

    INTEGER  shift, and go to state 8


State 5

    0 $accept: idlist $end .

    $default  accept


State 6

    2 idlist: variable COMMA . idlist

    IDENTIFIER  shift, and go to state 1

    idlist    go to state 9
    variable  go to state 3


State 7

    5 variable: variable LBRACK . INTEGER RBRACK

    INTEGER  shift, and go to state 10


State 8

    4 variable: IDENTIFIER LBRACK INTEGER . RBRACK

    RBRACK  shift, and go to state 11


State 9

    2 idlist: variable COMMA idlist .

    $default  reduce using rule 2 (idlist)


State 10

    5 variable: variable LBRACK INTEGER . RBRACK

    RBRACK  shift, and go to state 12


State 11

    4 variable: IDENTIFIER LBRACK INTEGER RBRACK .

    $default  reduce using rule 4 (variable)


State 12

    5 variable: variable LBRACK INTEGER RBRACK .

    $default  reduce using rule 5 (variable)
